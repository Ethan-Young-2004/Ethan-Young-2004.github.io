---
layout:     post
title:      "运维作业"
subtitle:   "第四周作业"
date:       2025-11-23
author:     "杨奕城"
tags:
    - 运维
    - Linux
    - 网络
    - shell
    - 进程
    - 定时任务
   
---


# 1.通过网络配置命令，让主机可以上网。 ip, netmask, gateway, dns，主机名。相关命令总结，最终可以通过这些配置让你的主机上网

## 配置文件位置

```
RedHat系列网卡配置文件位置：
/etc/sysconfig/network-scripts/ 目录中，以 ifcfg-XXX 的格式来命名
Ubuntu系统网卡配置文件位置：
从20.04之后，默认使用的都是netplan的管理模式了。网卡配置文件存在于 /etc/netplan/ 目录中，以 xxx.yaml 的格式来命名
Rocky9系统网卡配置文件位置：
/etc/NetworkManager/system-connections/ 目录中，以xxx.nmconnection 的格式来命名
```

## 定制网卡地址

### Centos8- | OpenEuler系统网卡定制

```
添加网卡
[root@openEuler ~]# cd /etc/sysconfig/network-scripts/
[root@openEuler network-scripts]# cp ifcfg-eth0 ifcfg-eth1
[root@openEuler network-scripts]# cat ifcfg-eth1
TYPE=Ethernet
ONBOOT=yes
IPADDR=10.0.0.131
PREFIX=24
GATEWAY=10.0.0.2
DNS1=10.0.0.2
DOMAIN=magedu.com

检查DNS解析文件
[root@openEuler network-scripts]# cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 10.0.0.2

通过重启网卡的方式重新加载配置
[root@openEuler network-scripts]# nmcli conn down eth1
[root@openEuler network-scripts]# nmcli connection reload
[root@openEuler network-scripts]# nmcli conn up eth1
Centos 7,8 通用：
手工：nmcli con down eth1;nmcli conn reload;nmcli conn up eth1
服务：systemctl restart NetworkManager
centos7：
服务：systemctl restart network
centos6及之前的版本：
服务：service network restart

查看dns解析配置文件
[root@openEuler network-scripts]# cat /etc/resolv.conf
# Generated by NetworkManager
search magedu.com # 简化默认域名的访问，自动补全域名后缀
nameserver 10.0.0.2
```

### Ubuntu系统网卡定制

```
定制网卡配置
root@ubuntu24:~# cat /etc/netplan/50-cloud-init.yaml
# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
  ethernets:
    eth0:
    ...
    eth2:
      dhcp4: no
      addresses:
      - "10.0.0.113/24"
      nameservers:
        addresses:
        - 10.0.0.2
      routes:
      - to: default
        via: 10.0.0.2
    eth1:
    ...
    

一台主机上，不要为多个网卡配置default的route

网卡生效
root@ubuntu24:/etc/netplan# netplan apply
```

### Rocky9定制网卡

#### 直接创建

```
定制设备关联信息
[root@rocky9 system-connections]# cat /etc/udev/rules.d/70-persistent-net.rules
SUBSYSTEM=="net",ACTION=="add",ATTR{address}=="00:0c:29:b1:f4:54",ATTR{type}=="1"
,NAME="eth0"
SUBSYSTEM=="net",ACTION=="add",ATTR{address}=="00:0c:29:b1:f4:5e",ATTR{type}=="1"
,NAME="eth1"

创建网卡文件
[root@rocky9 ~]# cd /etc/NetworkManager/system-connections/
[root@rocky9 system-connections]# cp eth0.nmconnection eth1.nmconnection

定制配置
[root@rocky9 system-connections]# cat eth1.nmconnection
[connection]
id=eth1
type=ethernet
autoconnect-priority=-999
interface-name=eth1
[ipv4]
address1=10.0.0.112/24,10.0.0.2
dns=10.0.0.2;
method=manual

重启主机
[root@rocky9 system-connections]# reboot
```

#### 生成rocky9的网卡配置文件

```
场景1：
1 添加新网卡
2 网卡处于未连接状态
3 nmcli device up -- 就可以生成配套网卡配置文件

场景2：
1 添加新网卡
2 网卡可能处于连接状态
3 断开网卡的连接状态
4 nmcli con reload -- 重载网卡的连接配置
3 nmcli device up -- 生成配套网卡配置文件
```

#### 网卡立刻生效方法

```
启动设备
[root@rocky9 system-connections]# nmcli device up ens256

定制配置
[root@rocky9 ~]# cd /etc/NetworkManager/system-connections/
[root@rocky9 system-connections]# cat ens256.nmconnection
[connection]
id=ens256
type=ethernet
autoconnect-priority=-999
interface-name=ens256
[ipv4]
address1=10.0.0.122/24,10.0.0.2
dns=10.0.0.2;
method=manual

重载配置
[root@rocky9 system-connections]# nmcli conn down ens256
[root@rocky9 system-connections]# nmcli conn reload
[root@rocky9 system-connections]# nmcli conn up ens256

网卡改名
[root@rocky9-12 ~]# nmcli con mod "有线连接 1" connection.id "ens256"
```

## 网络命令总结

### 主机名

#### hostname

临时设定主机名。不会将名字写入 /etc/hostname 文件

```
hostname
  -i|--ip-address #显示IP地址，仅显示能解析的地址
  -I|--all-ip-addresses #显示所有IP地址，但不显示IPV6地址，不显示回环地址
```

#### hostnamectl

永久设置主机名

```
hostnamectl hostname ubuntu-24 永久设置主机名
hostnamectl status 查看配置
```

### ifconfig

interface configuration

查看和修改网络接口的IP地址、子网掩码、广播地址、硬件地址（MAC地址）、激活或禁用网络接口等

该命令来自于net-tools包，可以直接使用 ip 代替

### route

该命令来自于net-tools包，建议使用 ip 代替

### netstat

netstat 是一个网络相关的命令行工具，它用于显示网络连接、路由表、接口统计、伪装连接和多播成员资格等信息。

```
netstat
  -r|--route #显示路由表
  -t|--tcp #显示tcp端口数据
  -u|--udp #显示udp端口数据
  -n|--numeric #以数字显示IP和端口
  -p|--program #显示相关进程及PID
  -l|--listening #仅显示处于监听状态的端口
  -a|--all #所有数据
  -I|--interfaces=<Iface> #指定设备
```

```
netstat -tulnp
```

### ip

#### ip link

```
link：网络设备的相关设定，包括MTU、MAC地址等。
ip link show：显示网络接口信息。
ip link set <interface> up：开启网卡。
ip link set <interface> down：关闭网卡。
ip link set <interface> name <newname>：修改网卡名称。
ip link set <interface> mtu <value>：设置网卡最大传输单元。
```

```
禁用网卡
[root@rocky9 ~]# ip link set ens160 down

网卡改名实践
[root@rocky9 ~]# ip link set ens160 name ens160-test

启用网卡功能
[root@rocky9 ~]# ip link set ens160-test up

查看网卡效果
[root@rocky9 ~]# ip link show ens160-test
1: ens160-test: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state
UP mode DEFAULT group default qlen 1000
link/ether 00:0c:29:11:98:e3 brd ff:ff:ff:ff:ff:ff
altname enp3s0
```

#### ip address

```
address（或addr）：额外的IP设定，如多IP的实现等。
ip addr show：显示网卡IP信息。
ip addr add <IP>/<prefixlen> dev <interface>：为指定网卡添加IP地址。
ip addr del <IP>/<prefixlen> dev <interface>：删除指定网卡上的IP地址。
```

```
为网卡增加ip地址：
向设备添加IP地址
[root@rocky9 ~]# ip address add 10.0.0.110/24 dev ens160

网卡别名：
添加别名
[root@rocky9 ~]# ip address add 10.0.0.114/24 dev ens160 label ens160:114

网卡IP地址移除：
删除IP地址
[root@rocky9 ~]# ip a del 10.0.0.110/24 dev ens160
删除别名
[root@rocky9 ~]# ip a del 10.0.0.114/24 dev ens160 label ens160:114

ip的有效期：
root@ubuntu24:~# ip a change 10.0.0.137/24 dev ens160 preferred_lft 10 valid_lft 10
参数解析：
  preferred_lft代表“preferred lifetime”，即首选生存时间。
    过了这个时间，地址仍然可以被接收数据包使用，但不应该用于发送新的数据包。
  valid_lft代表“valid lifetime”，即有效生存时间。
    过了这个时间，地址将不再被认为是有效的，不应该用于发送或接收数据包。
    
多ip：
增加多个IP地址
[root@rocky9 ~]# ip address add 10.0.0.110/24 dev ens160
[root@rocky9 ~]# ip address add 10.0.0.112/24 dev ens160
[root@rocky9 ~]# ip address add 10.0.0.114/24 dev ens160
检查设备的IP地址 - 单块网卡有4个IP地址
[root@rocky9 ~]# ip addr
清除网卡上所有IP
[root@rocky9 ~]# ip a flush dev ens160
检查设备的IP地址 - 恢复到一个IP地址
[root@rocky9 ~]# ip addr
```

#### ip route

```
添加路由
ip route add TARGET via GW dev IFACE src SOURCE_IP
添加网关：
ip route add default via GW dev IFACE
删除路由：
ip route del TARGET
显示路由：
ip route show|list
清空路由表：
ip route flush [dev IFACE] [via PREFIX]
查看路由过程
ip route get IP
```

```
查看路由：
[root@rocky9 ~]# ip route list

查看一个IP地址的路由：
[root@rocky9 ~]# ip route get 10.0.0.13

清空路由表：
[root@rocky9 ~]# ip route flush dev ens160 必须携带 dev 设备

默认路由：
删除默认路由
[root@rocky9 ~]# ip route del default
增加默认路由
[root@rocky9 ~]# ip route add default via 10.0.0.2 dev ens160

路由增加：
[root@rocky9 ~]# ip route add 11.0.0.0/24 via 10.0.0.12

路由删除：
[root@rocky9 ~]# ip route del 12.0.0.0/24
```

### ss

Socket Statistics

该命令来源于iproute包，可以代替netstat命令。

```
[root@rocky9 ~]# ss -tunlp
```

### nmcli

```
查看网络连接 nmcli con [show]
查看活跃连接 nmcli con show --active
查看指定设备 nmcli con show ens160
显示设备状态 nmcli dev status
网络接口属性 nmcli dev show ens160
删除连接 nmcli con del ens160
启用连接 nmcli con up ens160
禁用连接 nmcli con down ens160
刷新连接 nmcli connection reload
```

```
查看网卡设备连接信息
[root@rocky9 ~]# nmcli con

查看设备
[root@rocky9 ~]# nmcli dev show ens160
```

没有配套网卡的情况下：

1. nmcli device up 生成配置文件
2. 手工修改网卡配置文件，进行属性的定制
3. nmcli con down 设备、
4. systemctl restart NetworkManager

#  2.解析/etc/sysconfig/network-scripts/ifcfg-eth0配置格式

RedHat系列网卡配置文件位置：
/etc/sysconfig/network-scripts/ 目录中，以 ifcfg-XXX 的格式来命名

```
TYPE=Ethernet # 网络类型：以太网
PROXY_METHOD=none # 代理方法：无
BROWSER_ONLY=no # 仅浏览器使用：否（此选项通常用于某些特定的网络配置场
景）
BOOTPROTO=none # 启动协议：无（表示不使用如DHCP等自动获取IP的方式，采用静
态配置）
DEFROUTE=yes # 默认路由：是（此网络接口用于默认路由）
IPV4_FAILURE_FATAL=no # IPv4故障致命性：否（IPv4配置失败不会导致网络启动失
败）
IPV6INIT=yes # IPv6初始化：是（启用IPv6支持）
IPV6_AUTOCONF=yes # IPv6自动配置：是（允许系统自动配置IPv6地址）
IPV6_DEFROUTE=yes # IPv6默认路由：是（此网络接口用于IPv6默认路由）
IPV6_FAILURE_FATAL=no # IPv6故障致命性：否（IPv6配置失败不会导致网络启动失
败）
IPV6_ADDR_GEN_MODE=eui64 # IPv6地址生成模式：eui64（基于网络接口的唯一标识符生成
IPv6地址）
NAME=eth0 # 网络接口名称：eth0
UUID=0bb624f5-12ff-45e4-b950-00f743ea97b7 # 网络接口的唯一标识符（UUID）
DEVICE=eth0 # 设备名称：eth0（与网络接口名称相同）
ONBOOT=yes # 开机时自动启动：是
IPADDR=10.0.0.31 # IPv4地址：10.0.0.31（静态配置的IP地址）
PREFIX=24 # 网络前缀长度：24（表示子网掩码为255.255.255.0）
GATEWAY=10.0.0.2 # 默认网关：10.0.0.2
DNS1=10.0.0.2 # DNS服务器地址：10.0.0.2（首选DNS服务器）
# DNS2（次选DNS）、DNS3(第三DNS)、依次类推
DOMAIN=xxx.com # 用于简化域名访问用的配置，输入www会自动补全域名后缀
```

# 3.基于配置文件或命令完成bond0配置

## 添加两块仅主机网卡

![截图](/img/in-post/第四周作业/e63d6fc5ce57fe71e2da1e0976302aba.png)

## 确定网卡名

![截图](/img/in-post/第四周作业/fe450fedd80399ef4ca3221697d1ed89.png)

## 配置文件

```
[root@ubuntu netplan]# vim /etc/netplan/bond0.yaml
[root@ubuntu netplan]# cat /etc/netplan/bond0.yaml
network:
  version: 2
  ethernets:
    ens37:
      addresses: []
      dhcp4: false
    ens38:
      addresses: []
      dhcp4: false
  bonds:
    bond0:
      addresses: [192.168.8.124/24]
      interfaces: [ens37, ens38]
      parameters:
        mode: balance-rr
[root@ubuntu netplan]# chmod 600 /etc/netplan/bond0.yaml
[root@ubuntu netplan]# netplan apply
```

## 成功

![截图](/img/in-post/第四周作业/bcea182840286b0d2957b1eb09b2dca5.png)

# 4.通过ifconfig命令结果找到ip地址

![截图](/img/in-post/第四周作业/11945eb8c9fe0bd5b6fc87fd1dccca79.png)

# 5. 使用脚本判断 你主机所在网络内在线的主机IP有哪些？ ping通则在线

```
#!/bin/bash

current_ip=$(ip -4 addr show ens33 | grep 'inet ' | awk '{print $2}')
fping -a -g current_ip 2>/dev/null
```

#  6.使用while read line和/etc/passwd，计算用户id总和

```
#!/bin/bash

sum=0
while read line;do
  id=$(echo "$line" | awk -F: '{print $3}')
  ((sum+=id))
done < /etc/passwd
echo "$sum"
```

# 7.总结索引数组和关联数组，字符串处理，高级变量使用及示例

## 索引数组和关联数组

```
定制索引数组 - 数组的索引是普通的数字
declare -a array_name
- 普通数组可以不事先声明,直接使用

定制关联数组 - 数组的索引是自定义的字母
declare -A array_name
- 关联数组必须先声明,再使用


定制索引数组
[root@rocky9 ~]# course=(yuwen shuxue yingyu)
[root@rocky9 ~]# declare -a | grep course
declare -a course='([0]="yuwen" [1]="shuxue" [2]="yingyu")'

定制关联数组
[root@rocky9 ~]# score=([yingyu]="32" [yuwen]="67" [shuxue]="65")
[root@rocky9 ~]# declare -A | grep score
declare -A score='([yingyu]="32" [yuwen]="67" [shuxue]="65" )'
[root@rocky9 ~]# echo ${!score[@]}
yingyu yuwen shuxue
[root@rocky9 ~]# echo ${score[@]}
32 67 65
```

## 字符串处理

```
字符串截取
按分隔符截取: # 右 % 左
${file#/} 删除匹配结果，保留第一个/右边的字符串
${file##/} 删除匹配结果，保留最后一个/右边的字符串
${file%/} 删除匹配结果，保留第一个/左边的字符串
${file%%/} 删除匹配结果，保留最后一个/左边的字符串

字符串替换
${file/dir/path} 把第一个dir替换成path：/path1/dir2/dir3/n
${file//dir/path} 把所有dir替换成path：/path1/path2/path3/n
${file/#dir/path} 将从左侧能匹配到的dir，则替换成 path 然后返回；否则直接返回${var}。
${file/%dir/path} 将从右侧能匹配到的dir，则替换成 path 然后返回；否则直接返回${var}。

字符串转换
${file^^} 把file中的所有小写字母转换为大写
${file,,} 把file中的所有大写字母转换为小写

[root@rocky9 ~]# string=abc12342341
[root@rocky9 ~]# echo ${string#a*3} 匹配a到3，保留第一个a到3右边的字符串
42341
[root@rocky9 ~]# echo ${string##a*3} 匹配a到3，保留最后一个a到3右边的字符串
41
[root@rocky9 ~]# echo ${string%3*1} 匹配3到1，保留第一个3到1左边的字符串
abc12342
[root@rocky9 ~]# echo ${string%%3*1} 匹配3到1，保留最后一个3到1左边的字符串
abc12

[root@rocky9 ~]# str="apple, tree, apple tree, apple"
[root@rocky9 ~]# echo ${str/apple/APPLE} 第一个替换
APPLE, tree, apple tree, apple
[root@rocky9 ~]# echo ${str//apple/APPLE} 全部替换
APPLE, tree, APPLE tree, APPLE
[root@rocky9 ~]# echo ${str/#apple/APPLE} 左侧开始替换
APPLE, tree, apple tree, apple
[root@rocky9 ~]# echo ${str/%apple/APPLE} 右侧开始替换
apple, tree, apple tree, APPLE

[root@rocky9 ~]# str="apple, tree, apple tree, apple"
[root@rocky9 ~]# upper_str=${str^^} 转大写
[root@rocky9 ~]# echo ${upper_str}
APPLE, TREE, APPLE TREE, APPLE
[root@rocky9 ~]# lower_str=${upper_str,,} 转小写
[root@rocky9 ~]# echo ${lower_str}
apple, tree, apple tree, apple
```

## 高级变量

eval

实现多层隐藏命令的解析，还能够将相关环境的属性重现，从而实现多层隐藏命令的顺利执行

```
[root@rocky9 ~]# n=10
[root@rocky9 ~]# for i in $(eval echo {1..$n}); do echo "$i "; done
1
2
3
4
5
6
7
8
9
10

$(eval echo {1..$n})
  $n先解析为10，命令替换为 {1..10}
  通过 eval 带入 echo 命令环境
  $() 执行 echo {1..10} 输出为 1 2 3 4 5 6 7 8 9 10
  
[root@rocky9 ~]# echo 'hello-in-world' > infile.txt
[root@rocky9 ~]# cat infile.txt
hello-in-world
[root@rocky9 ~]# cmd="cat infile.txt"
[root@rocky9 ~]# echo $(${cmd})
hello-in-world
[root@rocky9 ~]# echo ${cmd}
cat infile.txt
借助于eval 和 $() 方式来实现隐藏命令的解读
[root@rocky9 ~]# eval ${cmd}
hello-in-world
[root@rocky9 ~]# echo $(${cmd})
hello-in-world

定制嵌套的环境变量
[root@rocky9 ~]# str=a
[root@rocky9 ~]# num=1
[root@rocky9 ~]# $str$num=hello
-bash: a1=hello: 未找到命令
借助于eval命令来实现
[root@rocky9 ~]# eval $str$num=hello
[root@rocky9 ~]# echo $a1
hello
```

# 8.求10个随机数的最大值与最小值

```
#!/bin/bash

for i in {0..9}; do
val[i]=$(( RANDOM % 100 + 1 ))
done

for ((i = 0; i < 9; i++)); do
  for ((j = 0; j < 9 - i; j++)); do
    if (( val[j] > val[j+1] )); then
      tmp=${val[j]}
      val[j]=${val[j+1]}
      val[j+1]=$tmp
    fi
  done
done

echo "min:${val[0]} max:${val[9]}"
```

#  9.使用递归调用，完成阶乘算法实现

```
#!/bin/bash

fact()
{
  local n=$1
  if ((n <= 1)); then
    echo 1
  else
    tmp=$(fact $((n - 1)))
    echo $((n * tmp))
  fi
}

read n
echo "$n! = $(fact n)"

优化版：
fact(){
  local n=$1
  (( n <= 1 )) && echo 1 && return
  local tmp=$(fact $((n - 1)))
  echo $((n * tmp))
}
```

# 10.通过shell编程完成，30鸡和兔的头，80鸡和兔的脚，分别有几只鸡，几只兔？

```
#!/bin/bash

head=30
leg=80

暴力解：
for (( i = 0; i <= head; i++)); do
  j=head-i
  if (( j * 4 + i * 2 == leg))
    echo "鸡：$i 兔：$j"
    exit
  fi
done

公式解：
j=$((leg/2-head))
i=$((head-j))
echo "鸡：$i 兔：$j"
```

#  11.结合编程的for循环，条件测试，条件组合，完成批量创建100个用户，

  1）for遍历1..100
  2）先id判断是否存在
  3）用户存在则说明存在，用户不存在则添加用户并说明已添加。                                                                                           

```
#!/bin/bash

for ((i = 1; i <= 100; i++)); do
  if id -u $i &>/dev/null; then
    echo "UID $i 已存在"
  else
    useradd -u $i "u$i"
    echo "UID $i 已添加"
  fi
done
```

# 12.解析进程和线程的区别？ 解析进程的结构

## 进程和线程的区别

|属性|进程|线程|
|--|--|--|
|定义|进程是操作系统资源分配的基本单位，它表示一个正在执行的程序实例。每个进程都有自己独立的代码和数据空间（程序上下文），以及系统分配的资源，如内存、文件句柄等。|线程是任务调度和执行的基本单位，它是进程中的一个执行实体。线程共享进程的资源，但每个线程都有自己独立的运行栈和程序计数器（PC）。线程使得程序能够并发执行多个任务。|
|开销|由于进程拥有独立的代码和数据空间，以及系统资源，因此在进程间切换时需要较大的开销，包括保存和恢复上下文、切换内存空间等。|线程切换时开销较小，因为线程共享进程的内存和资源，只需要切换线程的上下文即可。这使得多线程程序能够更高效地利用系统资源。|
|通信|进程是一个独立的运行实体，它可以独立地分配资源和调度。进程间的通信需要通过进程间通信（IPC）机制来实现。|线程共享进程的内存和资源，这使得线程间的通信更加高效。线程间的通信通常通过共享内存或消息传递来实现。|
|场景|适用于需要独立运行、资源隔离和较高安全性的场景，如操作系统中的服务进程、网络服务器等。|适用于需要高效并发执行、共享资源和较低开销的场景，如GUI应用程序中的事件处理线程、多线程服务器等。|

<br/>

## 进程的结构

每个进程都有自己的资源，由操作系统分配，内存，栈，文件描述符等信息。进程由程序、数据和进程控制块（Program Control Block，PCB）三部分组成。

- 程序是进程要执行的指令集合
- 数据是进程在执行过程中需要处理的信息
- 进程控制块则包含了进程的各种信息和控制信息，如进程标识符（PID）、状态、优先级、程序计数器、寄存器集合等。

# 13.结合进程管理命令，说明进程各种状态

## pstree

pstree以树状图的形式显示进程及其子进程的层次结构，清晰地表达了进程间的父子关系。

```
pstree
  -p 显示PID
  -ps 显示PID，显示父进程
  -pT 显示PID，不显示线程
  -h 高亮显示当前进程及父进程
```

## ps

process status，意为进程状态。通过ps命令，用户可以获取当前系统中正在运行的进程的各种详细信息，如进程ID（PID）、进程状态、CPU使用情况、内存占用、运行时间等。

```
ps
  a 显示所有终端
  u 显示用户
  x 显示与终端无关进程
  f 显示进程树

  -ef 显示进程与属主
  
  k 对属性排序,属性前加 - 表示倒序
  
显示所有所有进程，并列出属主
ps aux
显示所有所有进程，并列出属主
ps -ef
详细格式显示所有进程
ps -eFH

显示指定列
ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,comm
显示指定列
ps -axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
查询你拥有的所有进程
ps -x

查看进程的父子关系
ps auxf | head
```

## prtstat

```
prtstat
  -r raw

获取ping命令进程编号
[sswang@rocky9 ~]$ pidof ping
3610
显示进程信息
[sswang@rocky9 ~]$ prtstat 3610

按原始内容显示
[sswang@rocky9 ~]$ prtstat -r 3610
```

## 设置和调整进程优先级

```
nice

执行命令的时候，设定优先级
[root@rocky9 ~]# nice -n 11 ping www.baidu.com

调整运行中的进程优先级
[root@rocky9 ~]# renice -n -10 3887
```

## 搜索进程

```
pgrep
  -a all 详细完整的进程信息
  -t 指定tty
  -f full 使用完整的进程名匹配
  -u 用户
  
pidof
  -x 按文件名查找
  使用bash执行无法使用-x查找
  -s 多个结果时只显示一条
  
fuser

查找指定终端的进程
[root@rocky9 ~]# pgrep -at pts/1

查看sshd所有匹配到的进程号
[root@rocky9 ~]# pgrep -f ".*sshd.*"

根据用户检索进程id
[root@rocky9 ~]# pgrep -u sswang
4809

根据文件名查找nginx进程
root@ubuntu24:~# whereis nginx
nginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
root@ubuntu24:~# pidof -x /usr/sbin/nginx
1162 1161 1160

查找名为“nginx”的进程的所有PID
root@ubuntu24:~# pidof nginx

查找名为“nginx”的第一个进程的PID
root@ubuntu24:~# pidof -s nginx

指定端口查看进程
[root@rocky9-12 ~]# fuser 22/tcp
```

## 负载查询 uptime

每个内核当前活动进程数不大于3性能良好，超过5性能有严重问题

```
uptime
```

## cpu相关统计mpstat

```
mpstat
  -P ALL
```

## 进程实时状态top&htop

top用于实时显示系统的运行状况，特别是各个进程的资源和性能使用情况。

htop 是增强版的 top 命令，它提供了比传统的top命令更丰富的信息和功能，并以彩色方式展示进程列表，使得用户可以更直观地了解系统的运行状态。

```
top
    P 按CPU使用率对进程进行排序
    M 按内存使用量RES对进程进行排序
    T 按运行时间TIME或累积时间对任务排序
    t 显示当前时间、系统运行时间以及空闲/繁忙周期，尤其是图形比例图
    k 杀死指定的进程
    
[root@rocky9 ~]# top
top - 20:45:41 up 35 min, 1 user, load average: 0.00, 0.00, 0.00
Tasks: 287 total, 1 running, 286 sleeping, 0 stopped, 0 zombie
%Cpu(s): 0.0 us, 0.2 sy, 0.0 ni, 99.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
MiB Mem : 1743.4 total, 480.6 free, 826.2 used, 609.4 buff/cache
MiB Swap: 2064.0 total, 2064.0 free, 0.0 used. 917.3 avail Mem
字段解析
us 用户空间 sy 内核空间 ni 调整nice时间 id 空闲
wa 等待IO时间 hi 硬中断 si 软中断（模式切换） st 虚拟化消耗占比

10s刷新一次
[root@rocky9 ~]# top -d 10

显示指定用户的进程统计
[root@rocky9 ~]# top -u sswang

显示指定进程的线程
[root@rocky9 ~]# top -Hp 992

显示进程的具体命令
[root@rocky9 ~]# top -p 992 -c

执行时候，只显示一次
[root@rocky9 ~]# top -n 1
```

## free

free命令能够显示Linux系统中空闲的、已用的物理内存及swap内存，以及被内核使用的buffer和cache。

```
free
 -h human
 -s 每隔N秒刷新一次
 -c 输出N次后退出
```

## pmap

pmap命令是一个用于报告Linux进程内存映射关系的工具，它显示了进程的内存使用情况，包括代码段、数据段、堆栈等详细信息。

```
pmap
  -x 详细信息
  -d device
  -A 指定内存地址起始位置

查看 sshd 进程内存映射关系
[root@rocky9 ~]# pmap 1134

显示 sshd 详细的进程内存映射关系
[root@rocky9 ~]# pmap -x 1134

查看 sshd 进程内存映射关系，包括设备和路径
[root@rocky9 ~]# pmap -pd 1134

显示指定pid进程在内存中的占用情况
[root@rocky9 ~]# pmap -pd 1134 -A 000055a8e106f000,000055a8e107b000
```

## vmstat

vmstat命令生成的报告可用于平衡系统负载活动，帮助用户快速获取当前系统的负载情况，进行系统性能调优、故障排查等操作。

```
vmstat
  -s 显示事件统计
  
每秒显示一次
[root@rocky9 ~]# vmstat 1

显示统计数据
[root@rocky9 ~]# vmstat -s
```

## lsof

list open files，查看当前系统文件的工具。在linux环境下，一切皆文件，用户通过文件不仅可以访问常规数据，还可以访问网络连接和硬件如传输控制协议 (TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符。

```
列出所有打开文件
[root@rocky9 ~]# lsof | head

查看当前哪个进程正在使用此文件
[root@rocky9 ~]# lsof /var/log/messages
```

## kill

```
kill命令：
用于终止指定进程的运行。
需要通过"进程ID"（PID）来指定要终止的进程。支持同时写多个进程id数字，使用空格隔开。
可以发送多种信号给进程，其中SIGTERM（默认）和SIGKILL是两种常用的信号。

killall命令：
用于终结指定名称的所有进程。来源于psmisc软件
通过"进程名称"来匹配并终止进程，而不是进程ID。
同样可以发送多种信号，但默认也是发送SIGTERM信号。

pkill命令：
用于根据进程名或信号终止进程，功能类似于killall，但提供了更多选项。
可以直接跟进程名称，也可以跟其他选项来指定终止条件。
同样可以发送多种信号。
高级功能：
可以根据终端号踢出用户登录。
可以根据用户名终止所有进程。
可以使用模糊匹配来终止进程名包含特定字符串的进程。

显示所有信号
[root@rocky9 ~]# kill -l

killall 0 检测信号
[root@rocky9 ~]# killall -0 ping
[root@rocky9 ~]# echo $?
0
进程处于停止或僵尸状态，此方式仍然认为是进程是健康的


踢出指定终端
[root@rocky ~]# pkill -t pts/1
```

#  14.说明IPC通信和RPC通信实现的方式

IPC 是“本机内不同地址空间”交换数据的手段

RPC 是“跨网络不同主机”像调本地函数一样执行远程代码的机制。

## IPC

进程间通信 Inter-Process Communication 是一组编程接口，它允许程序员协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。
每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。

- 管道（PIPE）：一对一的单向传输
无名管道：是UNIX系统IPC最古老的形式，它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端，只能用于具有亲缘关系的进程之间的通信（如父子进程或兄弟进程之间）。
- 命名管道（FIFO）：可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中。
- 信号量（Semaphore）：
是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。
- 共享内存（Shared Memory）：
指两个或多个进程共享一个给定的存储区，这是最快的一种IPC方式，因为进程是直接对内存进行存取。
由于多个进程可以同时操作共享内存，因此需要进行同步，通常结合信号量使用。
- 套接字: socket
同一台主机上，可以通过 套接字文件【ip:port】 来实现双工通信。

## RPC

远程过程调用，Remote Procedure Call ，它允许客户端调用一个本地方法，而这个方法会透明地与远程服务器进行通信。具体来说，客户端方法会将参数打包成消息发送给服务器，服务器解包消息并执行相应操作，然后将结果返回给客户端。

# 15.总结Linux，前台和后台作业的区别，并说明如何在前台和后台中进行状态转换

## 前台和后台作业的区别

前台作业：通过终端启动，且启动后一直占据终端
后台作业：可通过终端启动，但启动后即转入后台运行（释放终端）
## 让作业运行于后台

运行中的作业： Ctrl+z
尚未启动的作业： COMMAND &
## 管理后台进程

```
#把后台进程送往前台
[root@rocky9 ~]# fg

#指定进程
[root@rocky9 ~]# fg 2

作业控制，让后台stop进程继续运行
[root@rocky9 ~]# jobs
[1] Stopped ./a.sh 123
[2]- Stopped ./a.sh 456
[3]+ Stopped ./a.sh 789

让后台stop 进程继续running
[root@rocky9 ~]# bg
[3]+ ./a.sh 789 &
[root@rocky9 ~]# bg 1
[1]- ./a.sh 123 &

[root@rocky9 ~]# jobs
[1] Running ./a.sh 123 &
[2]+ Stopped ./a.sh 456
[3]- Running ./a.sh 789 &
```

#  16.实现定时任务，每日凌晨1点，删除指定文件（自己创建即可）

```
0 1 * * * rm file
```

#  17.实现定时任务每月月初对指定文件进行压缩（自己创建文件）

```
0 0 1 * *  tar -zcvf file.tar.gz  ii/file
```

# 计划任务

- 一次性任务 at，batch
- 周期性任务 cron

需要mail服务

```
at
  -l 显示目前存在任务
  -d 删除

crontab
  -l list
  -e edit
  -u user
  -i 交互式
  -r remove

/etc/crontab
/etc/cron.d
/var/spool/cron/crontabs
```

### 计划任务时间

![screen-capture](/img/in-post/第四周作业/1e2d59d766245f204c5b5c83eabc4547.png)

执行日志有邮件，可重定向

%在cron中是换行含义，需要转义

