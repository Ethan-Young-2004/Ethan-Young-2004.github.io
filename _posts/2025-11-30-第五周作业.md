---
layout:     post
title:      "运维作业"
subtitle:   "第五周作业"
date:       2025-11-30
author:     "杨奕城"
tags:
    - 运维
    - Linux
    - 启动流程
    - 内核
    - systemd
    - DNS
---

# 1.总结Linux系统（包括不限于RockyLinux、Ubuntu）的启动流程

![截图](/img/in-post/第五周作业/6419cd88dd43961d73abcaf2e3700b0a.png)

1. 加载BIOS的硬件信息，获取第一个启动设备
2. 读取第一个启动设备MBR的引导加载程序(grub)的启动信息
3. 加载核心操作系统的核心信息，核心开始解压缩，并尝试驱动所有的硬件设备
4. 核心执行init程序，并获取默认的运行信息
5. init程序执行/etc/rc.d/rc.sysinit文件，重新挂载根文件系统
6. 启动核心的外挂模块
7. init执行运行的各个批处理文件(scripts)
8. init执行/etc/rc.d/rc.local
9. 执行/bin/login程序，等待用户登录
10. 登录之后开始以Shell控制主机

|详细技术流程|简化流程|对应关系说明|
|--|--|--|
|**POST加电自检**|**电源通电**|完全对应，简化说法省略了技术细节|
|**BIOS初始化硬件**|**BIOS初始化硬件**|完全对应|
|**MBR引导**|**BIOS加载Bootloader**|MBR引导是Bootloader加载的具体实现方式|
|**GRUB阶段1**|↑|GRUB是Bootloader的一种，MBR包含GRUB Stage1|
|**GRUB阶段1.5**|↑|属于Bootloader加载过程的一部分|
|**GRUB阶段2**|↑|完整的Bootloader运行阶段|
|**加载内核**|**Bootloader加载操作系统**|内核是操作系统的核心组件|
|**内核初始化**|↑|内核加载后的初始化过程|
|**Init进程启动**|↑|Init启动标志系统基本就绪|
|**系统服务启动**|**系统启动**|使系统达到可用状态|
|**用户登录界面**|↑|用户可见的启动完成标志|

## BIOS

Basic Input and Output System（基本输入输出系统），保存着有关计算机系统最重要的基本输入输出程序，系统信息设置，开机加电自检程序和系统启动自举程序等。

BIOS 就是一个程序，其代码存储在主板的一颗ROM存储芯片上，ROM是只能读不能写的，这颗芯片上的BIOS程序，在主板出厂的时候，己经固化好了，所以不管断不断电，这个BIOS程序都会一直存储在这颗芯片上。

当我们修改了BIOS里面的某些设置时，这个修改的数据是存储在另外一颗RAM存储芯片上，RAM掉电后数据就会消失，所以主板上有一颗纽扣电池来给这个RAM供电，当这颗纽扣电池没电了，BIOS里面的设置项，就又恢复成出厂设置了。

## bootloader

bios引导grub分为三部分

1. 0磁道0扇区
2. 1~2047扇区，文件系统驱动
3. /boot/grub/grub.conf

|阶段|顺序|存储位置|主要功能|
|--|--|--|--|
|**Primary Boot Loader<br/>1st Stage**|1|0磁道0扇区的前446字节空间内（MBR中）|• 突破启动扇区限制，启动后续阶段<br/>• 仅为内核加载做最基础的"铺路准备"<br/>• 不直接操作内核文件<br/>• 唯一作用是定位并加载Stage1.5或Stage2代码<br/>• 无法识别复杂文件系统，不能读取/boot分区内核文件|
|**Primary Boot Loader<br/>1.5 Stage**|2|1扇区到2047扇区（MBR后的保留区域）|• 过渡阶段，提供更高级的磁盘访问功能<br/>• 支持不同的文件系统<br/>• 帮助Stage1访问存储在磁盘分区中的更大引导程序文件<br/>• 存储Stage2的文件系统驱动，保证Stage2中的文件可读|
|**Secondary Boot Loader<br/>2nd Stage**|3|加载后运行在内存中，实际存储在/boot分区文件系统中|• 功能完整，支持解析配置文件grub.conf<br/>• 借助1.5阶段的文件系统驱动，从/boot分区读取内核文件（vmlinuz）和initramfs镜像<br/>• 直接负责内核和initramfs的加载<br/>• 完成加载和参数传递后，将系统控制权正式交给内核<br/>• 自身退出运行，后续由内核继续执行启动流程<br/>• 与内核加载关联最紧密的阶段|

### bios & bootloader

BIOS（基本输入输出系统 ）和 Bootloader（引导加载程序 ）是计算机启动流程中前后衔接、分工明确的关键组件。

BIOS 先运行，负责 “准备硬件环境”；之后把控制权交给 Bootloader，由它 “加载操作系统” 。

|对比项|BIOS|Bootloader|
|--|--|--|
|存储位置|主板上的 ROM/EEPROM 芯片（固件层面）|硬盘的特定分区（如 MBR 或 EFI 分区，软件层面）|
|运行时机|电脑通电后第一个运行的程序（最底层）|在 BIOS 完成硬件准备后接力运行|
|依赖关系|BIOS 负责"找到并加载" Bootloader|Bootloader 依赖 BIOS 准备好的硬件环境才能工作|
|核心目标|让硬件可用，为加载 Bootloader 做准备|让操作系统内核启动，完成"裸机"到"系统运行"的过渡|

## grub

GRUB（GRand Unified Bootloader）是一个启动加载程序，用于启动操作系统。其配置文件在Linux系统的启动过程中起着至关重要的作用。

目前grub的配置文件主要有两种样式：

- grub1的配置文件在 /boot/grub/grub.conf
- grub2的配置文件在 /boot/grub2/grub.cfg

### vmlinuz

vmlinuz是一个压缩的内核镜像文件，包含了Linux内核的压缩版本以及相关的启动信息。
在系统启动时，引导加载程序（如GRUB）会加载vmlinuz文件，并将其解压缩到内存中。

然后，操作系统的控制权会转移到内核镜像，从而启动Linux操作系统。

vmlinuz文件包含了操作系统的核心功能、驱动程序和必要的文件系统支持，负责初始化硬件设备、管理进程、提供系统调用接口等。

### initramfs

initramfs（initial ramdisk filesystem）是一个在内存中的临时根文件系统。

它在Linux内核启动之前被加载到内存中。initramfs包含了内核启动所需的文件系统模块和驱动程序，使得内核能够顺利地加载真正的根文件系统。一旦真正的根文件系统加载完成，initramfs就会被卸载，系统将转移到真正的根文件系统上运行。

### Rocky9 修改启动项实践

```
准备配置文件
[root@rocky9 ~]# cd /boot/loader/entries/
[root@rocky9 entries]# cp aa03379149d74770bc423657e9b6b442-5.14.0-
427.13.1.el9_4.x86_64.conf aa03379149d74770bc423657e9b6b442-7.14.0-
427.13.1.el9_4.x86_64.conf

修改配置文件
[root@rocky9 entries]# vim aa03379149d74770bc423657e9b6b442-7.14.0-
427.13.1.el9_4.x86_64.conf
# 添加 by xxx，修改内核版本等信息
title Rocky Linux by xxxx (7.14.0-427.13.1.el9_4.x86_64) 9.4 (Blue Onyx)
...

重启主机
[root@rocky9 entries]# reboot
```

## 加载内核

kernel 自身初始化过程

1. 探测可识别到的所有硬件设备
2. 加载硬件驱动程序（借助于ramdisk加载驱动）
3. 以只读方式挂载根文件系统
4. 运行用户空间的第一个应用程序

Centos6及以下版本的操作系统是 /sbin/init
Centos7及以上版本的操作系统是 /lib/systemd/systemd

### 路径问题

```
Centos6：
kernel /vmlinuz-2.6.32-71.el6.x86_64
initrd /initramfs-2.6.32-71.el6.x86_64.img

Rocky9：
linux /vmlinuz-5.14.0-427.13.1.el9_4.x86_64
initrd /initramfs-5.14.0-427.13.1.el9_4.x86_64.img
```

这两个/ 对应的是系统启动时/boot 分区的根目录。这是因为 GRUB（系统启动加载器）在引导阶段只能直接访问/boot 分区（GRUB 自身安装在/boot 或 MBR 中），所以这里的/ 默认指向/boot 的根目录，而非系统启动后的根文件系统/ 。

## init程序

init进程是内核启动的第一个用户级进程，它的进程ID（PID）通常为1。在Linux系统中，init进程负责如下作用：

- 系统初始化：
init进程在系统启动时执行一系列初始化操作，如设置系统环境、挂载文件系统等。
该程序是内核启动之后的第一个进程，也是进程树中的树根，所以其进程ID始终为1。
- 启动其他进程：
根据系统配置文件（如Linux中的/etc/inittab），init进程会启动其他必要的系统进程和服务。
- 监控与管理：
init进程还会监控系统中的其他进程，确保它们正常运行，并在必要时进行重启或终止。

## 系统启动

Linux 的运行级别（Runlevels）是一种定义系统操作模式的机制，用于控制系统启动后的行为和服务的可用性。不同的运行级别对应不同的系统状态，例如多用户模式、单用户模式、图形界面模式等。

- 一般使用3, 5做为默认级别
- 从centOS7开始，使用 target 来定义运行级别

### 运行级别说明与systemd target对应关系

|运行级别|传统说明|systemd target|指向的真实target|用途说明|
|--|--|--|--|--|
|0|关机|runlevel0.target|poweroff.target|系统关机|
|1|单用户模式(root自动登录)，single，维护模式|runlevel1.target|rescue.target|单用户维护模式，用于系统修复|
|2|多用户模式，启动网络功能，但不会启动NFS；维护模式|runlevel2.target|multi-user.target|多用户文本模式，基础网络服务|
|3|多用户模式，正常模式；文本界面|runlevel3.target|multi-user.target|完整的多用户文本模式（常用）|
|4|预留级别；可同3级别|runlevel4.target|multi-user.target|通常与级别3相同|
|5|多用户模式，正常模式；图形界面|runlevel5.target|graphical.target|完整的多用户图形模式（常用）|
|6|重启|runlevel6.target|reboot.target|系统重启|

```
查看现在使用的默认级别：
cat /etc/inittab
从CentOS7和Rocky8开始，使用systemd代替了传统的SysV init
systemctl get-default

设置默认级别：
systemctl set-default XXX.target

查看能够运行的模式
ls /usr/lib/systemd/system/

切换级别的方式：
手工方式：
  方法1：
    init N
  方法2：
    systemctl set-default XXX.target
文件方式：
  /etc/inittab

查看当前运行级别：
who -r
runlevel

切换运行级别（临时）：
init N

标准设置：
systemctl set-default XXX.target
```

# 2.总结内核设计流派及特点

- 单内核
- 微内核
- 混合内核
- 外核

## 内核架构类型对比表

### 单内核（Monolithic Kernel）

|对比维度|核心特点|
|--|--|
|**核心设计目标**|高性能优先，集成所有核心功能以减少模块通信开销|
|**功能部署位置**|进程调度、内存管理、文件系统、设备驱动等所有核心功能全在内核空间运行|
|**模块通信方式**|模块间直接函数调用（同一内核空间，无跨空间通信开销）|
|**典型代表系统**|Linux（传统架构）、BSD、早期 Unix|
|**核心优势**|✅ 性能高（减少 IPC 通信损耗）<br/>✅ 实现简单（功能集中，无需复杂通信机制）|
|**核心缺点**|❌ 耦合度高（修改功能需重编内核）<br/>❌ 风险集中（内核故障易导致系统崩溃）|

### 微内核（Microkernel）

|对比维度|核心特点|
|--|--|
|**核心设计目标**|高稳定性与安全性优先，通过极简内核隔离故障影响|
|**功能部署位置**|仅保留进程调度、内存管理、IPC等基础功能在内核空间，文件系统、驱动等在用户空间运行|
|**模块通信方式**|强制通过进程间通信（IPC）实现模块交互|
|**典型代表系统**|QNX、Minix、早期 Windows NT 设计|
|**核心优势**|✅ 稳定性强（用户态服务崩溃不影响内核）<br/>✅ 权限隔离严格（安全性高）|
|**核心缺点**|❌ 性能开销大（频繁 IPC 通信）<br/>❌ 开发复杂（需设计高效 IPC 机制）|

### 混合内核（Hybrid Kernel）

|对比维度|核心特点|
|--|--|
|**核心设计目标**|平衡性能与灵活性，核心功能保效率，非核心功能可动态调整|
|**功能部署位置**|基础核心功能在内核空间，驱动、文件系统等可灵活选择内核/用户空间|
|**模块通信方式**|内核空间内模块直接调用，跨空间模块使用 IPC 或动态加载机制|
|**典型代表系统**|Windows（NT之后架构）、Linux（通过 LKM 实现类混合特性）|
|**核心优势**|✅ 兼顾性能与灵活性<br/>✅ 适配场景广（桌面、服务器、嵌入式均可优化）|
|**核心缺点**|❌ 设计复杂（需权衡功能部署边界）<br/>❌ 调试难度高（跨空间交互问题定位困难）|

### 外内核（Exokernel）

|对比维度|核心特点|
|--|--|
|**核心设计目标**|极致灵活性，让应用直接掌控硬件资源，实现深度定制化|
|**功能部署位置**|仅提供最底层硬件抽象在内核空间，文件系统、驱动等全在用户空间由应用实现|
|**模块通信方式**|应用通过极简硬件接口与内核交互，用户态服务间自主通信|
|**典型代表系统**|学术研究项目（如 MIT Exokernel），暂未大规模商用|
|**核心优势**|✅ 灵活性极致<br/>✅ 资源利用率高（无冗余内核功能）|
|**核心缺点**|❌ 开发门槛极高<br/>❌ 生态稀缺（缺乏商用软件支持）|

# 3.总结systemd服务配置文件

服务文件

### unit 文件格式说明

以 `#` 开头的行后面的内容会被认为是注释
相关布尔值 1，yes，on，true 等可以表示开启，0，no，off，false 等都可以表示关闭
时间单位默认是秒，如果要使用其它时间单位，毫秒(ms)，分钟(m) 等须显式说明

### 配置解读

service unit file文件通常由三部分组成

|配置段|功能描述|
|--|--|
|**[Unit]**|定义与 Unit 类型无关的通用选项，提供描述信息、行为控制及依赖关系|
|**[Service]**|定义 Service 类型的专用选项，包括进程管理、执行命令等|
|**[Install]**|定义服务启用/禁用时的安装选项，用于 `systemctl enable/disable`|

#### [Unit] 段配置选项

|字段|说明|
|--|--|
|**Description**|服务描述信息|
|**Documentation**|服务帮助信息|
|**After**|定义启动顺序，当前服务在指定服务之后启动|
|**Before**|定义启动顺序，当前服务在指定服务之前启动|
|**Requires**|强依赖关系，被依赖服务失败则当前服务也失败|
|**Wants**|弱依赖关系，被依赖服务失败不影响当前服务|
|**Conflicts**|冲突关系|

#### [Service] 段配置选项

|字段|说明|
|--|--|
|**Type**|定义影响ExecStart及相关参数的功能的unit进程启动类型（详见下方 Type 类型表）|
|**EnvironmentFile**|环境变量配置文件路径|
|**PIDFile**|生成进程文件路径|
|**ExecStart**|服务启动命令（绝对路径）|
|**ExecStartPre**|启动前执行的命令|
|**ExecStartPost**|启动后执行的命令|
|**ExecReload**|重载配置时执行的命令|
|**ExecStop**|停止服务时执行的命令|
|**Restart**|进程退出时是否自动重启|
|**RestartSec**|重启等待时间（默认 100ms）|
|**KillSignal **|以何信号杀死进程，默认SIGTERM|
|**KillMode**|以何种方式杀死进程control-group\|process|
|**TimeoutStopSec**|在超过此时间后，如果进程没有被杀死，则继续使用SIGKILL配置或 FinalKillSignal配置停止进程|
|**PrivateTmp**|是否使用私有临时目录，布尔值，true 表示会生成私有的tmp目录，路径是/tmp/systemd-private- UUID-NAME.service-XXXXX/tmp/|

#### Service Type 类型说明

|Type 类型|说明|
|--|--|
|**simple**|默认类型，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中|
|**forking**|由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务, 原生父程序在启动结束后就会终止|
|**oneshot**|一次性进程，执行完成后退出|
|**dbus**|需要获取 D-Bus 名称后才能继续，通常也要同时设定BusNname|
|**notify**|启动完成后发送通知信号，需要配合NotifyAccess来让Systemd 接收消 息|
|**idle**|等待所有任务完成后才启动，通常是开机到最后才执行的服务|

#### [Install] 段配置选项

|字段|说明|
|--|--|
|**WantedBy**|工作模式，指定在哪个运行级别下启用服务|
|**Alias**|服务别名|
|**Also**|同时安装的其他相关服务|

#### daemon-reload

对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件，或者选择重启系统

```
systemctl daemon-reload
init q
```

### 定制服务文件

```
定义service的unit文件
root@ubuntu24:~# vim /lib/systemd/system/hello.service
[Unit]
Description=Hello World
[Service]
TimeoutStartSec=0
ExecStart=/bin/sh -c "while true; do echo Hello World; sleep 1; done"
ExecStop=/bin/kill sh
[Install]
WantedBy=multi-user.target

如果while语句命令太长了，可以编写成一个脚本，然后将脚本赋予执行权限
最后，将脚本的绝对路径放到 ExecStart 后面即可
主命令可以使用bash -c 方式，kill bash 是配套的。
由于文件环境的作用范围限制，不会影响到系统的bash程序运行

加载配置文件
root@ubuntu24:~# systemctl daemon-reload

启用
root@ubuntu24:~# systemctl enable --now hello

查看状态
root@ubuntu24:~# systemctl status hello
```

# 4.总结DNS域名三级结构，DNS服务工作原理，涉及递归和迭代查询原理

## 域名三级结构

- 根域：全球共有13台IPV4根域名服务器，其中10台在美国，2台在欧洲，1台在亚洲
- 一级域名：又称顶级域名，可分为三类，一类代表国家和地区(cn，hk，......)，一类代表各类组织(com，edu，......)，以及反向域
- 二级域名：某个具体组织，单位，机构，商业公司或个人使用，需要向域名管理机构申请(付费)才能获得使用权
- 二级域名以下的域名，由使用该域名的组织自行分配

## DNS服务工作原理

![截图](/img/in-post/第五周作业/3bdbf0799a30f449bee738ae085781f1.png)

1. 当客户端主机决定访问 https://www.magedu.com 这个域名时，
2. 先查询本地 hosts 文件，是否有对应IP地址，如果有，则直接访问该IP地址，域名解析服务结束；
3. 再查询本机缓存，如果本机缓存没有解析记录，则会向其配置的DNS服务器发起解析请求；
4. DNS代理解析服务器会先查询其缓存是否有这条解析记录，如果有，则直接返回，如果没有，则继续向上解析；
5. DNS代理解析服务器会向根域名服务器发起解析请求，根域名服务器返回 com 域名的DNS地址；
6. DNS代理解析服务器继续向 com 域名服务器发起解析请求，com 域名服务器返回 magedu.com 域名服务器DNS地址；
7. DNS代理解析服务器继续向 magedu.com 域名服务器发起解析请求，magedu.com 域名服务器返回www.magedu.com 主机的IP；
8. DNS代理解析服务器将 www.magedu.com 的IP地址存入本机缓存，再读取缓存，将 IP地址发送给客户端主机；
9. 客户端主机通过IP地址顺利访问 https://www.magedu.com；

## 递归和迭代查询

![截图](/img/in-post/第五周作业/1bda89445efaeec1641104646544fdf7.png)

### 递归查询

是指DNS服务器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果DNS服务器本地没有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。

一般客户机和本地DNS服务器之间属于递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到最终的肯定或否定的结果后转交给客户机。

此查询的源和目标保持不变，为了查询结果只需要发起一次查询。

递归算法：客户端向LocalDNS发起域名查询-->localDNS不知道域名对应的IP-->但它知道谁知道->他代为帮客户端去查找-->最后再返回最终结果。

### 迭代查询

是指DNS服务器在收到用户发起的请求时，并不直接回复查询结果，而是告诉另一台DNS服务器的地址，用户再向这台DNS服务器提交请求，这样依次反复，直到返回查询结果。

一般情况下(有例外)本地的DNS服务器向其它DNS服务器的查询属于迭代查询，如：若对方不能返回权威的结果，则它会向下一个DNS服务器(参考前一个DNS服务器返回的结果)再次发起进行查询，直到返回查询的结果为止。此查询的源不变，但查询的目标不断变化，为查询结果一般需要发起多次查询。

迭代算法：客户端向LocalDNS发起域名查询-->localDNS不知道域名对应的IP-->但它知道谁知道并推荐客户端应该找谁-->客户端自己去找它。

# 5.实现私有DNS, 供本地网络主机作DNS递归查询

```
安装bind
apt install -y bind9 

启动服务
systemctl enable --now named.service 

修改选项配置文件
vim /etc/bind/named.conf.options
  1 options {
  2     directory "/var/cache/bind";
  3
  4     // If there is a firewall between you and nameservers you want
  5     // to talk to, you may need to fix the firewall to allow multiple
  6     // ports to talk.  See http://www.kb.cert.org/vuls/id/800113
  7
  8     // If your ISP provided one or more IP addresses for stable
  9     // nameservers, you probably want to use them as forwarders.
 10     // Uncomment the following block, and insert the addresses replacing
 11     // the all-0's placeholder.
 12
 13     // forwarders {
 14     //  0.0.0.0;
 15     // };
 16
 17     //========================================================================
 18     // If BIND logs error messages about the root key being expired,
 19     // you will need to update your keys.  See https://www.isc.org/bind-keys
 20     //========================================================================
 21     dnssec-validation auto;
 22     listen-on { any; };
 23     listen-on-v6 { any; };
 24
 25     allow-query { localhost; 10.0.0.0/24; };
 26
 27     recursion yes;
 28     allow-recursion { localhost; 10.0.0.0/24; };
 29
 30     forwarders {
 31         8.8.8.8;
 32         223.5.5.5;
 33     };
 34 };

重启服务
systemctl reload named
```

![截图](/img/in-post/第五周作业/e8b893ec8266dd422246e5d3da94131c.png)

![截图](/img/in-post/第五周作业/548676bade56cb1835b8b91a3f30a8a3.png)

# 6.总结DNS服务器类型，解析答案，正反解析域，资源记录定义

## DNS服务器类型

|类型|英文名称|作用|特点|典型示例|
|--|--|--|--|--|
|**根域名服务器**|Root Server|返回顶级域服务器的地址|全球13组，存储根域信息|a.root-servers.net|
|**顶级域服务器**|TLD Server|管理特定顶级域的解析|返回权威服务器的地址|gtld-servers.net|
|**权威域名服务器**|Authoritative Server|存储具体域名的解析记录|提供最终的域名解析答案|ns1.example.com|
|**递归解析器**|Recursive Resolver|代理客户端完成DNS查询|缓存结果，减少查询次数|8.8.8.8, 114.114.114.114|

## 解析答案

### 权威应答 & 非权威应答

```
[root@rocky9 ~]# dig www.magedu.com
; <<>> DiG 9.16.23-RH <<>> www.magedu.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 53360
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
# 主域名由13提供解析，所以这里提示 aa 即权威应答
...
[root@rocky9 ~]# dig www.bj.magedu.com
; <<>> DiG 9.16.23-RH <<>> www.bj.magedu.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 10848
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
#子域名由13转发到子域名服务器，所以这里没有提示 aa 即非权威应答
...
子域指定DNS，也是权威应答
[root@rocky9 ~]# dig www.bj.magedu.com @10.0.0.14
; <<>> DiG 9.16.23-RH <<>> www.bj.magedu.com @10.0.0.14
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 61654
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
# 子域名由15主机解析，所以这里提示 aa 即权威应答
```

## 正反解析域

### 正向查找区域

正向查找区域，又称域名解析区域，是指将DNS名称（即域名）转换为IP地址的过程。当用户输入一个域名时，DNS服务器会在正向查找区域中查找对应的IP地址，从而使用户能够访问到目标服务器。

正向查找区域是DNS服务器中最常用的功能之一。无论是访问网站、发送电子邮件还是进行其他网络活动，都需要通过正向查找区域将域名解析为IP地址。

工作原理：

当用户输入一个域名时，DNS服务器会首先检查本地缓存中是否已有该域名的解析结果。如果本地缓存中没有，则会向根DNS服务器发送查询请求。根DNS服务器会返回顶级域DNS服务器的地址，顶级域DNS服务器再返回权威域DNS服务器的地址。最终，权威域DNS服务器会返回该域名对应的IP地址，完成域名解析过程。

### 反向查找区域

反向查找区域，又称IP反向解析区域，是指将IP地址转换为DNS名称（即域名）的过程。与正向查找区域相反，反向查找区域是通过查找IP地址的PTR记录来得到该IP地址指向的域名。

反向查找区域主要用于电子邮件系统的安全性验证、网络诊断和安全审计等方面。例如，当一封电子邮件发送到收件人的邮箱时，邮件服务器可以通过反向查找区域验证发件人的IP地址是否对应一个合法的域名，从而防止垃圾邮件和钓鱼邮件的发送。

工作原理：

反向查找区域的工作原理与正向查找区域类似，但查询的方向相反。当需要进行反向查找时，DNS服务器会查询反向查找区域中的PTR记录，找到与IP地址对应的域名。如果找到了对应的域名，则说明该IP地址是合法的；如果没有找到对应的域名，则说明该IP地址可能是非法的或未注册的。

## 资源记录

在DNS（域名系统）中，Resource Record（资源记录）是DNS数据库中存储的信息单元，用于提供关于域名及其相关服务的信息。每个RR（Resource Record）都包含以下字段：

- Owner：记录的所有者，通常是一个域名。
- TTL（Time to Live）：生存时间，指定其他DNS服务器在放弃缓存该记录之前应将其缓存多长时间。
- CLASS：类，指示记录所属的类别。最常用的类别是IN（Internet类）。
- TYPE：类型，指示记录的类型，如A记录（表示IPv4地址）、AAAA记录（表示IPv6地址）、NS记录（表示权威名称服务器）等。
- RDATA：资源数据，随CLASS和TYPE的变化而变化，用于描述与记录相关的具体信息。