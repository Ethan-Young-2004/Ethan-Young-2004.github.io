---
layout:     post
title:      "运维作业"
subtitle:   "第六周作业"
date:       2025-12-10
author:     "杨奕城"
tags:
    - 运维
    - Linux
    - 时间同步
    - 日志
    - inotify
    - rsync
    - sersync
---



# 1.总结sudo配置文件格式，总结相关示例。

sudo（superuser do 的缩写）是一个在类Unix操作系统（如Linux和macOS）中广泛使用的命令，它允许授权的用户以另一个用户（通常是超级用户或root）的安全权限来运行命令,如halt，reboot，su等。

这样可以减少系统对root账户的依赖，使root不必经常在线，从而可以提高系统安全性，在最早之前，一般用户管理系统的方式是利用su切换成为超级管理员，但是，使用su切换，必须要先知道root用户的密码。

- root用户将普通用户的名字，可以执行的特定命令，按照哪种用户或用户组的身份执行等信息，登记在特殊文件中(通常是 /etc/sudoers)，即完成对该用户的授权(此时此用户被称为 sudoer )。
- 在一般用户需要取得特殊权限时，其可在命令前加上 sudo，此时sudo会询问该用户自己的密码(以确定是当前用户在操作)，回答后系统即会将该命令的进程以root用户的权限运行。

## sudoers

```
授权user用户可以在host主机上以runas的身份执行 command，TAG可为空
  user host=(runas) [TAG:]command
常见的TAG： NOPASSWD，表示执行命令的时候，不需要验证

root ALL=(ALL:ALL) ALL # (所有者:归属组)
root ALL=(ALL) ALL

%wheel ALL=(ALL) ALL
%#10 ALL=(%#0) /bin/cat /var/log/secure

上面所有的部分都可以通过别名的方式来定制
类型：User_Alias|Runas_Alias|Host_Alias|Cmnd_Alias
格式：Alias_Type NAME = item1, item2, ...

别名名称由大写字母开始，后面接大写字母，数字，下划线
NAME = [A-Z]([A-Z][0-9]_)*

使用别名的方法设定
User_Alias ANLMAL=tom,jerry,%wheel,#1013,%#1014
Runas_Alias ROOT=root
Host_Alias LOCAL=rocky9,10.0.0.12
Cmnd_Alias CMD=/sbin/init *,/usr/bin/yum update
Cmnd_Alias SHUTDOWN=/sbin/shutdown -h now
ANLMAL LOCAL=(ROOT) CMD,SHUTDOWN
```

# 2.搭建时间同步服务器，详细总结配置和搭建过程

## 时间同步服务

多主机协作工作时，各个主机的时间同步很重要，时间不一致会造成很多重要应用的故障，如：加密协议，日志，集群等。 利用NTP（Network Time Protocol） 协议使网络中的各个计算机时间达到同步。

目前NTP协议属于运维基础架构中必备的基本服务之一。

## NTP

NTP（Network Time Protocol）时间同步将系统时钟和世界协调时UTC同步，精度在局域网内可达0.1ms，在互联网上绝大多数的地方精度可以达到1-50ms。ntp 是使用渐进性同步机制，如果本地时间与标准时间相差较大，则需要一定的时间才能同步完成；

## Chrony时间同步

实现NTP协议的的自由软件。可使系统时钟与NTP服务器，参考时钟（例如GPS接收器）以及使用手表和键盘的手动输入进行同步。还可以作为NTPv4（RFC 5905）服务器和对等体运行，为网络中的计算机提供时间服务。

设计用于在各种条件下良好运行，包括间歇性和高度拥挤的网络连接，温度变化（计算机时钟对温度敏感），以及不能连续运行或在虚拟机上运行的系统。

Chrony是一个更现代的时间同步服务，它比NTP具有更高的精度和更快的同步速度。

```
配置示例
pool ntp.ubuntu.com iburst maxsources 4
属性解析：
server时钟服务器地址，加iburst 选项表示服务可用时，加快初始同步速度。
pool语法和指令与server 字段相似，不同之处在于其指定的NTP服务可以解析多个IP地址
maxsources <数量>：限制从该池中选择的服务器数量（如 maxsources 3 表示最多用 3 个）。
minpoll/maxpoll：最小/最大同步间隔（单位：秒，以 2 的幂计算，如 minpoll 4 表示 16 秒）
prefer：标记为优先使用的服务器（当多个源可用时优先选择）

其他属性
driftfile根据实际时间计算出计算机增减时间的比率，将它记录到一个文件中，会在重启后为系统时钟作出补偿
rtcsync启用内核模式，系统时间每11分钟会拷贝到实时时钟（RTC）
allow指定可以使用本机服务的设备，格式可以是IP，子网，网段
deny指定不可以使用本机服务的设备，格式可以是IP，子网，网段
cmdallow指定设备可以通过chronyd使用控制指令cmddeny指定设备不可以通过chronyd使用控制指令
bindcmdaddress允许chronyd监听哪个接口来接收由chronyc执行的命令
makestep 强制chronyd在调整期大于某个阀值时调整系统时钟
local stratum 10即使server指令中时间服务器不可用，也允许将本地时间作为标准时间授时给其它客户端
```

![截图](/img/in-post/第六周作业/31329cba7d59d632162154671eeb5a29.png)

## 集群规划

|IP|主机角色|系统版本|备注|
|--|--|--|--|
|10.0.0.150|NTP server|Ubuntu 22|配置成为服务端，为内网提供 NTP 时间同步服务|
|10.0.0.151|NTP client|Rocky 8|将本机的 server 指向 150，从 150 上同步时间|
|10.0.0.152|NTP client|Ubuntu 22|将本机的 server 指向 150，从 150 上同步时间|

```
Ubuntu系统需要单独安装chrony包
apt install chrony
```

## 服务端配置:

```
修改配置文件
vim /etc/chrony/chrony.conf
 20 #pool ntp.ubuntu.com        iburst maxsources 4
 21 #pool 0.ubuntu.pool.ntp.org iburst maxsources 1
 22 #pool 1.ubuntu.pool.ntp.org iburst maxsources 1
 23 #pool 2.ubuntu.pool.ntp.org iburst maxsources 2
 24
 25 server ntp.aliyun.com iburst
 26 allow 10.0.0.0/24
 27 local stratum 10
 
重启服务
systemctl restart chronyd.service\

关闭防火墙
systemctl stop ufw.service
```

## Rocky客户端配置:

```
修改配置文件
vim /etc/chrony.conf
  3 #pool 2.pool.ntp.org iburst
  4 server 10.0.0.150 iburst

重启服务
systemctl restart chronyd.service
```

## Ubuntu客户端配置:

```
修改配置文件
vim /etc/chrony.conf
 24 server 10.0.0.150 iburst

重启服务
systemctl restart chronyd.service
```

## 结果验证

![截图](/img/in-post/第六周作业/76304312b6f61ff2048a9c1656b0c46b.png)

# 3.总结常见的日志服务管理的常见日志服务

## 主机级别

### sysklogd 系统日志服务

在 CentOS5 以及之前的发行版中，其采用的 sysklogd 服务来记录和管理系统日志的。sysklogd
服务有两个模块：

- klogd： 用于记录 linux kernel 相关的日志
- syslogd：用于记录用户空间应用日志

### rsyslog 系统日志服务

RSYSLOG 就是 Rocket-fast SYStem for LOG processing，即极速日志处理系统。rsyslog 是CentOS6 以后的版本中使用的日志管理程序，是一个默认安装的服务，并且默认开机启动。

## 集群级别

### ELK 日志服务

ELK 是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。在后续发展的过程中增加了一个 FileBeat，这几款软件通常在一起配合使用，各司其职。ELK 主要用于部署在企业架构中，收集多台设备上多个服务的日志信息，并将其统一整合后提供给用户。

rsyslog 主要用于单机日志管理，ELK 主要用于分布式集群环境中的日志管理。

# 4.总结日志分类, 优先级别。图文并茂解释应用如何将日志发到rsyslog,并写到目标。

## 设施定位

在 rsyslog 里，“设施” 就像是不同的信息分类标签，用来给各种系统消息进行归类。或者可以简单理解为数据的来源范围。

在一台主机上会同时运行多个服务和软件，每个服务或软件都有可能会产生大量的日志，如果每个服务或软件产生的日志都独立存放管理，那文件数量就太多了，如果都放到一个文件中，似乎也不是很合适，所以rsyslog 将日志进行了分类，相同类型的日志放一个文件，这样便于管理。

### syslog 内置分类

```
LOG_AUTH #auth 安全和认证相关的日志
LOG_AUTHPRIV #authpriv 安全和认证相关的日志，私有
LOG_CRON #cron 系统定时任务 crontab 与 at 产生的相关日志
LOG_DAEMON #daemon 各守护进程产生的日志
LOG_FTP #ftp ftp守护进程产生的日志
LOG_KERN #kern 内核产生的日志
LOG_LOCAL0 -- LOG_LOCAL7 #local0-local7 自定义分类
LOG_LPR #lpr 打印服务日志
LOG_MAIL #mail 邮件服务日志
LOG_NEWS #news 网络新闻服务产生的日志
LOG_SYSLOG #syslog syslogd 服务自己的日志
LOG_USER #user 用户等级
LOG_UUCP #uucp uucp子系统的日志信息
* #通配符，代表所有分类

LOG_LOCAL0 到 LOG_LOCAL7 是一组特殊的日志设施（facility），它们被设计为供本地使用或开发者自定义的软件类别使用。这些设施允许系统管理员或开发者将特定服务的日志消息定向到指定的日志文件或执行特定的动作。
具体来说，每个 LOG_LOCAL 设施（从 LOG_LOCAL0 到 LOG_LOCAL7）都可以被视为一个自定义的日志通道，用于收集和记录来自特定应用程序或服务的日志信息。
在rsyslog中，LOG_LOCAL0 到 LOG_LOCAL7 并不代表日志的级别，它仅用于自定义日志分类的设施标识。
```

## 优先级定位

在 rsyslog 里，优先级就像是给系统消息的重要程度和紧急情况排了个队。

rsyslog 在记录日志的时候，将各种产生日志的事件和行为进行了优先级的排序，使用者可以根据不同环境(测试/生产)和需求，设置不同的级别来记录日志，这样可以保证，记录下来的内容都是是我们想要的。

rsyslog 内置优先级分类，从高到低，如果在记录日志时，设置了优先级，则只会记录设定的优先级和高于设定优先级的日志

### 优先级类型

```
LOG_EMERG #emerg/panic 紧急，致命错误
LOG_ALERT #alert 告警，当前状态必须立即进行纠正
LOG_CRIT #crit 关键状态的警告，例如 硬件故障
LOG_ERR #err/error 其它错误
LOG_WARNING #warning/warn 警告级别的信息
LOG_NOTICE #notice 通知级别的信息
LOG_INFO #info 通告级别的信息
LOG_DEBUG #debug 调试程序时的信息
* #所有级别的日志
none #不需要任何日志
#panic,error,warn在新版中被弃，不建议使用
```

- 日志先按 Facility 分类，再按 Priority 分级。
- rsyslog 用「facility.priority」规则决定处理动作。

语法格式：

facility.priority  ‑>  动作（文件/远程/数据库...）

重要动作前缀：- 表示异步写、@ 表示 UDP、@@ 表示 TCP

![Untitled diagram-2025-12-08-103109.png](/img/in-post/第六周作业/97719031569544b9a76572851370ea1a.png)

# 5.完成功能，将3个主机(要求主机名为ip)的ssh日志，通过rsyslog服务将ssh日志写入到集中的主机上的rsyslog服务，写入到/var/log/all-ssh.log文件

## 目标

![截图](/img/in-post/第六周作业/79659ade891f91d531a2782b492d990f.png)

将 3 台主机（主机名=IP）的 SSH 日志，通过 rsyslog 集中汇总到  **10.0.0.150** 的 `/var/log/all-ssh.log`，统一管控。

## 主机清单

|IP|操作系统|主机名|角色|备注|
|--|--|--|--|--|
|10.0.0.150|Ubuntu 22|10.0.0.150|log-server|接收 514/UDP，写入 all-ssh.log|
|10.0.0.151|Rocky 8|10.0.0.151|client-1|转发本地 SSH 日志|
|10.0.0.152|Ubuntu 22|10.0.0.152|client-2|转发本地 SSH 日志|

## 服务端配置:

```
配置 server log 主机，开启 TCP, UDP 相关功能
vim /etc/rsyslog.conf
 16 # provides UDP syslog reception
 17 module(load="imudp")
 18 input(type="imudp" port="514")
 19
 20 # provides TCP syslog reception
 21 module(load="imtcp")
 22 input(type="imtcp" port="514")

新增配置文件，日志都写到 all-ssh.log 文件中
vim /etc/rsyslog.d/sshd.conf
  1 :programname, isequal, "sshd"  /var/log/all-ssh.log

重启服务：
systemctl restart rsyslog
systemctl restart ssh
```

## Rocky客户端配置:

```
配置远程转发，转发到 10.0.0.150 的 udp 协议514端口
vim /etc/rsyslog.d/net.conf
  1 :programname, isequal, "sshd"   @10.0.0.150:514

重启服务
systemctl restart rsyslog
```

## Ubuntu客户端配置:

```
配置远程转发，转发到 10.0.0.150 的 tcp 协议514端口
vim /etc/rsyslog.d/net.conf
  1 :programname, isequal, "sshd"   @@10.0.0.150:514

重启服务
systemctl restart rsyslog
```

## 测试效果

```
ssh 10.0.0.152
ssh 10.0.0.151
tail /var/log/all-ssh.log
```

![截图](/img/in-post/第六周作业/3e447b1f3871f819b01d932cbfa63e2d.png)

![截图](/img/in-post/第六周作业/49a35d42a3a4b9faa69bcdb441217336.png)

### 服务端可以接收到日志

![截图](/img/in-post/第六周作业/1d6e58cb73b316d14c0d6b8e8642311c.png)

# 6.总结/var/log/目录下常用日志文件作用。

|日志文件|作用说明|
|--|--|
|/var/log/messages 或 /var/log/syslog|系统主日志，记录系统启动、运行过程中的重要信息和错误消息（RH系用messages，Debian系用syslog）|
|/var/log/kern.log|内核日志，记录Linux内核产生的消息，包括硬件检测、驱动程序问题|
|/var/log/boot.log|系统启动日志，记录系统启动过程中的详细信息|
|/var/log/auth.log 或 /var/log/secure|认证和授权日志，记录用户登录、sudo使用、SSH连接等安全相关事件|
|/var/log/wtmp|登录记录数据库，包含所有用户登录/注销活动（使用last命令查看）|
|/var/log/lastlog|记录每个用户最后一次登录信息（使用lastlog命令查看）|
|/var/log/cron|计划任务日志，记录cron定时任务的执行情况|
|/var/log/maillog 或 /var/log/mail.log|邮件系统日志，记录邮件服务器的收发情况|
|/var/log/httpd/ 或 /var/log/nginx/|Web服务器日志目录，包含访问日志(access.log)和错误日志(error.log)|
|/var/log/mysql/ 或 /var/log/postgresql/|数据库服务日志，记录数据库查询错误、连接问题|
|/var/log/dmesg|系统启动时的硬件检测和内核环缓冲区消息|
|/var/log/audit/audit.log|审计框架日志，记录系统安全审计事件|
|/var/log/yum.log 或 /var/log/dpkg.log|软件包管理日志，记录软件安装、更新、删除等操作|

# 7.使用inotify + rsync和sersync实现文件的同步，并且总结两种方式的优缺点

## inotify + rsync

### 软件安装

```
apt install inotify-tools


yum install epel-release
yum install inotify-tools
yum install rsync
```

### 服务端

```
定制配置
指定映射账号，指定日志文件，指定远程连接用户名和密码，禁用匿名连接
vim /etc/rsyncd.conf
  1 uid=root
  2 gid=root
  3 max connections=0
  4 log file=/var/log/rsyncd.log
  5 pid file=/var/run/rsyncd.pid
  6 lock file=/var/run/rsyncd.lock
  7 [dir1]
  8 path=/data/dir1/
  9 comment=rsync dir1
 10 read only=no
 11 auth users=rsyncer
 12 secrets file=/etc/rsyncd.pwd


指定认证时候专用的密码文件后，重启服务
echo 'rsyncer:123456' > /etc/rsyncd.pwd
chmod 600 /etc/rsyncd.pwd
systemctl restart rsync.service
```

### 客户端

```
mkdir /data/www/ -p
mkdir /data/scrips -p
echo 123456 > /data/scrips/www_rsync.pwd
chmod 600 /data/scrips/www_rsync.pwd

vim /data/scrips/rsync.sh
  1 #!/bin/bash
  2
  3 USER="rsyncer"
  4 PASS_FILE="/data/scrips/www_rsync.pwd"
  5 REMOTE_HOST="10.0.0.150"
  6 SRC="/data/www/"
  7 REMOTE_DIR="dir1"
  8 DEST="${USER}@${REMOTE_HOST}::${REMOTE_DIR}"
  9 LOG_FILE="/data/scrips/www_rsync.log"
 10
 11 # 准备工作环境
 12 ubuntu_install_inotify(){
 13     if [ ! -f /usr/bin/rsync ]; then
 14         apt install inotify-tools -y
 15         apt install rsync -y
 16     fi
 17 }
 18
 19 centos_install_inotify(){
 20     if [ ! -f /usr/bin/rsync ]; then
 21         yum install inotify-tools -y
 22         yum install rsync -y
 23     fi
 24 }
 25
 26 install_inotify(){
 27     os_type=$(grep Ubuntu /etc/issue >/dev/null && echo "Ubuntu" || echo "CentOS")
 28     if [ "${os_type}" == "Ubuntu" ]; then
 29         ubuntu_install_inotify
 30     else
 31         centos_install_inotify
 32     fi
 33 }
 34
 35 # 不间断监控指定目录中的特定事件，当目录中有事件发生变化时，调用 rsync 命令进行同步
 36 rsync_file(){
 37     inotifywait -mrq --exclude=".*\.swp" \
 38         --timefmt '%Y-%m-%d %H:%M:%S' \
 39         --format '%T %w %f' \
 40         -e create,delete,moved_to,close_write,attrib ${SRC} \
 41     | while read DATE TIME DIR FILE; do
 42           FILEPATH=${DIR}${FILE}
 43           rsync -az --delete --password-file=${PASS_FILE} $SRC $DEST && \
 44           echo "At ${TIME} on ${DATE}, file ${FILEPATH} was backup via rsync" >> ${LOG_FILE}
 45       done
 46 }
 47
 48 # 主函数
 49 main(){
 50     install_inotify
 51     rsync_file
 52 }
 53
 54 # 执行主函数
 55 main

执行脚本文件
/bin/bash /data/scrips/rsync.sh
```

### 测试结果

```
touch /data/www/f1
cp /etc/fstab /data/www/
dd if=/dev/zero of=/data/www/test.img bs=1M count=10
mkdir -pv /data/www/dira/dirb/dirc

tree /data/dir1
```

![截图](/img/in-post/第六周作业/1912c27f1b58faef9ebe0b796a21f908.png)

![截图](/img/in-post/第六周作业/b58368dc869744c440d5c040a62e65e8.png)

### PS:客户端创建服务

```
vim /etc/systemd/system/rsync-inotify.service
  1 [Unit]
  2 Description=Real-time sync via inotify+rsync
  3 After=network-online.target
  4 Wants=network-online.target
  5
  6 [Service]
  7 Type=simple
  8 ExecStart=/bin/bash /data/scrips/rsync.sh
  9 Restart=always
 10 RestartSec=5s
 11
 12 [Install]
 13 WantedBy=multi-user.target


systemctl daemon-reload
systemctl enable --now rsync-inotify
```

## sersync

<br/>

```
mkdir /data/softs -p
cd /data/softs

wget https://gitee.com/zhang-sanfeng-01/images/raw/master/img/sersync2.5.4_64bit_binary_stable_final.tar.gz

tar xf sersync2.5.4_64bit_binary_stable_final.tar.gz

vim GNU-Linux-x86/confxml.xml
 12     <inotify>
 13     <delete start="true"/>
 14     <createFolder start="true"/>
 15     <createFile start="true"/>
 16     <closeWrite start="true"/>
 17     <moveFrom start="true"/>
 18     <moveTo start="true"/>
 19     <attrib start="true"/>
 20     <modify start="true"/>
 21     </inotify>

 24     <localpath watch="/data/www">
 25         <remote ip="10.0.0.150" name="dir1"/>
 26     </localpath>

 29         <auth start="true" users="rsyncer" passwordfile="/etc/rsyncd.pwd"/>


rm -rf /data/www/*
mkdir /data/www/dira/dirb/dirc -p

echo 123456 > /etc/rsyncd.pwd
chmod 600 /etc/rsyncd.pwd

cd GNU-Linux-x86/
./sersync2 -dr
```

![截图](/img/in-post/第六周作业/0fd4037128069fc3b367dd2a812d6253.png)

## 两种方式的优缺点

|维度|inotify+rsync|sersync（基于 inotify 二次开发）|
|--|--|--|
|部署成本|系统自带 inotify-tools，轻量|需额外下载二进制/源码，依赖 C++ 运行库|
|配置复杂度|需自己写脚本、加闸门、排重|一份 xml 搞定，支持多目录、多目标|
|同步性能|事件触发+全目录扫描，闸门后可缓解|内部记录变更文件列表，增量上传，只传变化的文件|
|大文件场景|每次全量比对，CPU/IO 高|只传差异块，优势明显|
|多对一/一对多|脚本里自己循环目标|原生支持多 target 标签|
|容错/监控|需自己加日志、systemd 保活|自带失败重试、crontab 全量校验、web 监控接口|
|社区活跃度|inotify-tools 稳定但更新慢|作者已多年不维护，GitHub  issue 无人回，适合内网|
|典型问题|1. 频繁事件风暴 2. 自引用循环|1. 多年未更新 2. 64 位系统需手动编译 3. 配置出错时难调试|
