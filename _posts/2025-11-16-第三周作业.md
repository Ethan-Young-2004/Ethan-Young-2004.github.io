---
layout:     post
title:      "运维作业"
subtitle:   "第三周作业"
date:       2025-11-16
author:     "杨奕城"
tags:
    - 运维
    - Linux
    - 磁盘
    - 分区
    - 文件系统
    - RAID
    - LVM
    - shell
---

# 1.磁盘存储术语总结和理解

Linux 哲学思想：一切皆文件
对于硬件设备，在Linux系统中，也是以文件的形式呈现出来的

|术语|描述|
|--|--|
|head 磁头|一个盘面对应一个磁头|
|track 磁道|一圈一个磁道|
|sector 扇区|磁道划分成扇形|
|cylinder 柱面|多个磁头所对应的磁道柱面|
|partition 分区|磁盘上逻辑独立的空间，包括主分区、拓展分区和逻辑分区|
|IOPS|每秒输入输出操作次数|
|bandwidth 带宽|硬盘数据传输的速率|

# 2.总结MBR,GPT结构区别

## 分区原因

- 优化I/O性能
- 实现磁盘空间配额限制
- 提高修复速度
- 隔离系统和程序
- 安装多个OS
- 采用不同文件系统

## 分区方式

- MBR
- GPT

## MBR

Master Boot Record，用32位表示扇区数，分区不超过2T

0磁道0扇区：512bytes

- 446bytes: boot loader 启动相关
- 64bytes：分区表，其中每16bytes标识一个分区
- 2bytes: 55AA，标识位

一块硬盘最多有4个主分区，也可3主分区+1扩展(N个逻辑分区)

- 0磁道0扇区上64B空间存储分区表信息，一个分区的关键信息要占用16B

MBR分区：主和扩展分区对应的1--4，/dev/sda1，逻辑分区从5开始，/dev/sda5

- 记录分区开始和结束位置的空间均为4B，最多有2的32次方个扇区，一个扇区512B，则最大空间是 2^32*2^9=2^41 B

```
hexdump -C -n 512 /dev/sda 查看分区表信息
dd if=/dev/sda of=/data/dpt.img bs=1 count=64 skip=446 备份MBR分区表
scp /tmp/dpt.img 10.0.0.157: 备份到远端
```

## GPT

- 支持128个分区，使用64位，支持8Z（ 512Byte/block ）64Z （ 4096Byte/block）
- 使用128位UUID(Universally Unique Identifier) 表示磁盘和分区，GPT分区表自动备份头和尾两份， 并有CRC校验位
- UEFI (Unified Extensible Firmware Interface 统一可扩展固件接口)硬件支持GPT，使得操作系统可以启动

GPT分区结构分为4个区域：

- GPT头
- 分区表
- GPT分区
- 备份区域

# 3.总结学过的分区，文件系统管理

## 管理分区

```
lsblk
  -a 输出所有设备信息
  -p 显示设备全路径
  -f 显示文件系统
  
parted（慎用）
  -l 显示所有硬盘分区信息
  
fdisk
  -l 显示
  p 输出分区列表
  t 更改分区类型
  n 创建新分区
  d 删除分区
  w 保存并退出
  q 不保存退出
  
gdisk
  -l 显示
  p 输出分区列表
  t 更改分区类型
  n 创建新分区
  d 删除分区
  w 保存并退出
  q 不保存退出

partprobe CentOS 7,8 同步分区表

查看所有分区列表
[root@rocky9 ~]# fdisk -l
Disk /dev/nvme0n1：200 GiB，214748364800 字节，419430400 个扇区
...
Disk /dev/sda：200 GiB，214748364800 字节，419430400 个扇区
...
Disk /dev/sdb：200 GiB，214748364800 字节，419430400 个扇区
...
Disk /dev/mapper/rl-root：70 GiB，75161927680 字节，146800640 个扇区
...
Disk /dev/mapper/rl-swap：2.02 GiB，2164260864 字节，4227072 个扇区
...
Disk /dev/mapper/rl-home：126.98 GiB，136344240128 字节，266297344 个扇区
...

指定磁盘查看分区信息
[root@rocky9 ~]# fdisk -l /dev/sdb
Disk /dev/sdb：200 GiB，214748364800 字节，419430400 个扇区
磁盘型号：VMware Virtual S
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节

仅显示特定的列信息
[root@rocky9 ~]# fdisk -lo id,size,type /dev/sda
Disk /dev/sda：200 GiB，214748364800 字节，419430400 个扇区
磁盘型号：VMware Virtual S
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
磁盘标签类型：dos
磁盘标识符：0xd2fe6fd0
Id 大小 类型
83 1G Linux
8e 199G Linux LVM

创建新分区的完整流程解析：
进入手动分区交互模式
[root@rocky9 ~]# fdisk /dev/sdb
命令(输入 m 获取帮助)：m # 输入m 查看命令帮助
命令(输入 m 获取帮助)：p # 输入p 查看分区
命令(输入 m 获取帮助)：n # 输入n 创建新分区
选择 (默认 p)： # 按Enter 创建主分区
分区号 (1-4, 默认 1): # 按Enter 创建编号1的主分区

更改分区标识：
命令(输入 m 获取帮助)：t # 输入t 修改分区类型
分区号 (1-4, 默认 4): # 按Enter 修改编号4的分区类型
Hex 代码或别名（输入 L 列出所有代码）：L # 输入L，查看分区类型的标识
Hex 代码或别名（输入 L 列出所有代码）：05 # 输入 05，调整 4号主分区为扩展分区

删除分区：
通过 d 命令删除指定的分区
d -> Enter # 删除6号分区
d -> Enter # 删除5号分区
d -> Enter # 删除4号分区
结果显示：
删除分区是，按照倒序的方式来删除，避免间隔的空闲空间

扩展分区：
命令(输入 m 获取帮助)：n
分区类型
p 主分区 (3 primary, 0 extended, 1 free)
e 扩展分区 (逻辑分区容器)
选择 (默认 e)： #
默认值
将使用默认回应 e。
已选择分区 4
第一个扇区 (62916608-419430399, 默认 62916608):
# 默认值
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (62916608-419430399, 默认 419430399):
# 默认值
创建了一个新分区 4，类型为“Extended”，大小为 170 GiB。
命令(输入 m 获取帮助)：p

保存分区：
命令(输入 m 获取帮助)：w # 输入 w 保存分区
```

## 文件系统选择管理

```
mkfs.ext4 /dev/sdc1 创建ext4 文件系统
  
mke2fs ext系列文件系统专用管理工具

df
  -l 查看己挂载的设备

blkid
  -U 根据指定的UUID来查找对应的设备
  -L 根据指定的LABEL来查找对应的设备
  
e2lable 管理ext系列文件系统的LABEL

findfs 查找分区

tune2fs 重新设定ext系列文件系统可调整参数的值
  -l 查看指定文件系统信息
  
dump2fs 显示ext文件系统信息，将磁盘块分组管理

xfs_info 显示已挂载的 xfs 文件系统信息

fsck File System Check
  fsck.ext4 /dev/sdc1
  
e2fsck ext系列文件专用的检测修复工具

xfs_repair xfs文件系统专用检测修复工具

将 /dev/sdb 磁盘格式化为 ext4 文件系统
[root@rocky9 ~]# mkfs.ext4 /dev/sdb

将 /dev/nvme0n1 格式化为 xfs 文件系统
[root@rocky9 ~]# mkfs.xfs /dev/nvme0n1p1

检测文件系统
[root@rocky9 ~]# lsblk -f /dev/sdb
```

## 挂载

将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为

卸载：为解除此关联关系的过程

挂载点下原有文件在挂载完成后会被临时隐藏，因此，挂载点目录一般为空 进程正在使用中的设备无法被卸载

```
mount
  -a 自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中)
  -o 挂载选项列表，以英文逗号分隔
    ro 只读

umount

mount 通过mount命令查看挂载情况

findmnt 查看挂载点情况

lsof 查看正在访问指定文件系统的进程

fuser -km MOUNT_POINT 终止所有在正访问指定的文件系统的进程

挂载只读的ext4文件系统
[root@rocky9 ~]# mount /dev/sdb1 -o ro /mount/ext

检查挂载效果
[root@rocky9 ~]# lsblk -f /dev/sdb1

挂载正常操作的xfs文件系统
[root@rocky9 ~]# mount -t xfs /dev/nvme0n1p2 /mount/xfs

指定设备名进行卸载
[root@rocky9 ~]# umount /dev/sdb1

查看磁盘格式化的文件系统信息
lsblk -f 磁盘设备名

查看所有已挂载的文件系统信息
df 或者 df -Th

查看已挂载的所有文件系统
mount

查看挂载点的状态
findmnt <磁盘设备名> <挂载点>
```

### 查看挂载情况

```
fuser
```

### 持久化挂载

etc/fstable

```
mount -a 新增挂载项后需要执行，只对新增行或删除行有效，修改挂载选项无效
```

修改挂载选项无效通过重新挂载解决

```
mount -o remount MOUNTPOINT
```

mbr逻辑分区使用设备标识删除后可能会出错，使用UUID避免出错

![screen-capture](/img/in-post/第三周作业/110bd7cfdf236dc2dca00d94c6d50cc1.png)

## 处理交换文件和分区

- 交换分区
- 交换文件

```
mkswap 创建swap分区
dd if=/dev/zero of=/swapfile bs=1G count=2 以文件作为swap分区

swapon 启用swap分区
  -s 显示已使用交换设备的摘要
  -a 激活 /etc/fstab 中的所有交换区

swapoff 禁用swap分区
```

新添加swap后需要先off再on生效

priority越大越优先使用

使用文件做交换权限改成600

使用分区交换性能更加好

![screen-capture](/img/in-post/第三周作业/50c50bdff30f6b49120e9164d4c1844e.png)

对比内存swap性能不好，使用k8s时禁用swap

永久禁用swap

```
#删除swap行
[root@ubuntu2204 ~]# sed -i.bak '/swap/d' /etc/fstab
#或注释swap行
[root@ubuntu2204 ~]# sed -i.bak '/swap/s@^@#@' /etc/fstab
```

swap使用策略

当内存占用到达指定值时使用交换分区

设为0代表内存占满时开始使用，60代表使用到40%开始使用

```
[root@centos8 ~]# cat /proc/sys/vm/swappiness
30

#修改
[root@rocky86 ~]# vim /etc/sysctl.conf
vm.swappiness=0

#生效
[root@rocky86 ~]# sysctl -p
vm.swappiness = 0
```

## 移动介质

有移动介质也需要挂载，挂载点通常在/media 或/mnt下

访问前，介质必须被挂载

摘除时，介质必须被卸载

自动挂载

```
apt install autofs
```

## 磁盘常见工具

### df

```
df 文件系统查看工具
  -T 显示文件系统类型
  -h 以方便阅读的方式显示
```

### du 目录统计工具

```
du
  -s 只显示外层目录
  -h 以方便阅读的方式显示
```

### dd

```
dd if= of= bs= count=
```

# 4.总结raid 0, 1, 5, 10, 01的工作原理。总结各自的利用率，冗余性，性能，至少几个硬盘实现。

## RAID0

以chunk为单位，读写并行，没有冗余，一个硬盘损坏全部丢失

80G+100G组合->160G

硬盘大小：最小硬盘大小*硬盘数量

至少2个硬盘实现

## RAID1

硬盘互为镜像，读取速度等于硬盘数量倍数，写入速度降低

硬盘大小：最小硬盘大小

实现数据的完全冗余，提供了最高的数据安全性

至少2个硬盘实现

## RAID4

多块数据盘异或运算值存于校验盘

硬盘大小：（N-1）*最小硬盘大小

## RAID5

raid4的校验值存储盘故障概率高

校验值分别存储

可以容错一个磁盘的故障

硬盘大小：（N-1）*最小硬盘大小

至少3个硬盘实现

## RAID6

双份校验位

最多允许坏两块盘

硬盘大小：（N-2）*最小硬盘大小

## RAID10

先raid1再raid0

硬盘大小：N*最小硬盘大小/2

既提供了RAID 0的高性能，又具备了RAID 1的数据冗余和容错能力

每组镜像只允许坏一块

至少4个硬盘实现

## RAID01

先raid0再raid1

硬盘大小：N*最小硬盘大小/2

性能与RAID10接近

只能坏 1 块，且第二块不管坏在哪都直接掉阵

至少4个硬盘实现

|维度|RAID10 (1+0)|RAID01 (0+1)|
|--|--|--|
|结构|先镜像后条带|先条带后镜像|
|4 盘容错|可坏 1 块，可坏 2 块|只能坏 1 块|
|重建速度|快（只拷单盘）|慢（整侧重算）|
|性能衰减|坏 1 块降 1/n，平滑|坏 1 块降 50 %，剧烈|

## JBOD

多块拼成连续大空间

第一块存储分段信息如果损坏全部失效

# 5.总结LVM的基本原理，完成实验对LVM的创建和磁盘扩容。

## 逻辑卷管理器LVM

操作系统内堆硬盘

LVM（Logical Volume Manager）即逻辑卷管理器，是Linux系统下对磁盘分区进行管理的一种机制。LVM在硬盘分区和文件系统之间添加了一个逻辑层，为文件系统屏蔽了下层的磁盘分区布局，提供了一个抽象的卷组，用户可以在这个卷组上创建文件系统。

![LVM_component.png](/img/in-post/第三周作业/fd423f69a623f9eba2720bc59dd1bdfe.png)

### pv

将块设备创建为物理卷，本质上就是给块设备打一个标签，
块设备数量和物理卷数量是对应的，有几个块设备，就可以创建几个物理卷，
块设备容量大小不限，可以跨分区。

```
pvs 显示pv信息
pvcreate 创建pv
pvremove 删除pv
```

### vg

```
vgs 显示卷组
vgdisplay

vgcreate 创建卷组
  -s 指定PE大小，数字加单位，单位为 k|K|m|M|g|G|t|T|p|P|e|E
  
vgextend 往卷组中添加物理卷

vgreduce 从卷组中移除物理卷

vgremove 删除卷组
```

### lv

```
lvs 显示逻辑卷
lvdisplay

lvcreate 创建逻辑卷
  -l 100 100个PE
  -l 20%free 可用PE数量的 20%
  -l 10%vg 指定vg的10%
  -L 5G

lvextand 扩展逻辑卷，需要再扩容文件系统
  -l +100
  -l +20%free
  -l +10%vg
  -L +5G
  
lvreduce 缩减逻辑卷，缩减有数据损坏的风险，不支持在线缩减，要先取消挂载
  
lvresize
```

逻辑分区和普通分区一样需要创建文件系统后使用

### 跨主机迁移逻辑卷

在旧系统中，umount 所有卷组上的逻辑卷

禁用卷组

```
vgchange -a n vg0
```

导出卷组

```
vgexport vg0
```

拆下旧硬盘在目标计算机上，并导入卷组

```
vgimport vg0
```

启用

```
vgchange -ay vg0
```

mount 所有卷组上的逻辑卷

### 逻辑卷快照

只保留最初原始版本，第一次修改推到快照，后续修改不再推入，大小取决于变化部分的原文件大小

### 创建快照

```
lvcreate -n NAME -s -L 100M -p r /dev/testvg/lv3
```

快照只读

### 从快照还原

```
lvconvert --merge
```

还原后快照就消失，是一次性的

# 6.总结变量命名规则，不同类型变量（环境变量，位置变量，只读变量，局部变量，状态变量）如何使用。

## shell变量命名法则

### 命名规则

- 区分大小写
- 不能使用保留字
- 只能使用字母数字下划线，不能数字开头

### 命名习惯

- 见名知义
- 变量大写
- 局部变量小写
- 函数名小写
- 大小驼峰

## 变量定义和使用

- 普通变量 当前进程中生效
- 环境变量 当前进程和子进程生效，可被子进程继承
- 本地变量 当前进程中代码片段中生效

```
. abc.sh当前进程执行
./abc.sh当前进程子进程执行
```

```
set 定义变量
unset 销毁变量
```

## 环境变量

可以传到子进程中

```
export
declare -x

export name=VALUE
declare -x name=VLAUE
```

![screen-capture](/img/in-post/第三周作业/fe3897a2b275097df69ea388379259bc.png)

## 只读变量

```
readonly
declare -r

readonly PI=3.1415
declare -r PI=3.1415
```

只能声明定义，但后续不能修改和删除，即常量

## 位置变量

```
$1,$2,... 对应第1个、第2个等参数，shift [n]换位置
$0 命令本身,包括路径
$* 传递给脚本的所有参数，全部参数合为一个字符串
$@ 传递给脚本的所有参数，每个参数为独立字符串
$# 传递给脚本的参数的个数
```

在bash shell中内置的变量, 在脚本代码中调用通过命令行传递给脚本的参数

## 局部变量

只能在函数内定义

```
local NAME=VALUE
```

## 状态变量

进程执行后，将使用变量 \$? 保存状态码的相关数字，不同的值反应成功或失败，$?取值范围 0-255

# 7.编写一个脚本猜数字，使用判断提示用户比目标数字是大还是小

```
#!/bin/bash
val=$(( RANDOM % 100 + 1 ))
while true
do
read -p "猜一个数，范围1~100:" input
if ((val > input));then
        echo 小了;
elif ((val < input));then
        echo 大了;
else
        echo 对了;
        exit;
fi
done


优化版：
#!/bin/bash
val=$(( RANDOM % 100 + 1 ))
while read -p "猜一个数，范围1~100:" input;do
  ((val==input))&&{ echo 对了;exit;}
  (( val > input )) && echo 小了 || echo 大了
done
```
